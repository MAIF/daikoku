import { nanoid } from "nanoid";
import { isError, IUserSimple } from "../../types";

import * as Services from '../../services';
import { toast } from "sonner";
import { IPasskey } from "../backoffice";

export const createPassKeyCredential = (
  username: string,
  displayName: string,
  challengeBufferString: string,
  userId: string
) => {
  /*
    The challenge is a buffer of randomly generated bytes with a minimum of 16 bytes. 
    This is generated on the server using a cryptographically secure random number generator. 
    By generating the challenge on the server we can prevent "replay attacks". 
    The authenticator will sign this along with other data.
  */

  console.debug({ challengeBufferString })
  const challengeBuffer = base64urlDecode(challengeBufferString)

  const userIdBuffer = new TextEncoder().encode(userId);

  const publicKeyCredentialCreationOptions: PublicKeyCredentialCreationOptions =
  {
    authenticatorSelection: {
      authenticatorAttachment: "cross-platform",
      userVerification: "preferred",
      residentKey: "required",
    },
    challenge: challengeBuffer,
    rp: {
      name: "daikoku",
      ...(window.location.hostname !== 'localhost' && { id: window.location.hostname })
    },
    user: {
      id: userIdBuffer,
      name: username,
      displayName: displayName,
    },
    // SUPPORT ALL PASSKEYS
    pubKeyCredParams: [
      { type: "public-key", alg: -7 },   // ES256
      { type: "public-key", alg: -257 }, // RS256
      { type: "public-key", alg: -8 },   // EdDSA
    ],
    timeout: 15000,
    attestation: "none",
  };

  console.debug(
    `✅  publicKeyCredentialCreationOptions : ${publicKeyCredentialCreationOptions}`
  );

  return navigator.credentials.create({
    publicKey: publicKeyCredentialCreationOptions,
  });
};

const validatePassKeyCreation = (credential: Credential): string | null => {
  const clientDataValidation = validateClientData(credential);
  switch (clientDataValidation.valid) {
    case true:
      return clientDataValidation.challenge;
    case false:
      return null;
  }
};

interface PassKeyClientDataValidation {
  valid: boolean;
  challenge: string | null;
}
const validateClientData = (
  credential: Credential
): PassKeyClientDataValidation => {

  // Gather the Client Data
  const decoder = new TextDecoder(); // @ts-ignore
  const clientData: { type: string, challenge: string, origin: string } = JSON.parse(decoder.decode(credential.response.clientDataJSON));
  // console.debug({ clientData, credential, clientDataJSON: credential.response.clientDataJSON })
  console.log("✅  Gathered Client Data: ", clientData);
  if (clientData.origin !== "https://daikoku.oto.tools:5173") {
    console.log("❌  Origin does not match!", clientData.origin);
    return {
      valid: false,
      challenge: null,
    };
  } else if (clientData.type !== "webauthn.create") {
    console.log("❌  Type does not match webauthn.create");
    return {
      valid: false,
      challenge: null,
    };
  }
  console.log("✅  Client Data is Valid");
  return {
    valid: true,
    challenge: clientData.challenge,
  };
};


export const loginWithPasskey = () => {
  const challengeId = nanoid(32)
  Services.beginPasskeyAssertion(challengeId)
    .then(r => {
      if (isError(r))
        return Promise.reject(r.error)
      else
        return r
    })
    .then(r => {
      const challengeBuffer = base64urlDecode(r.challenge)
      return navigator.credentials.get({
        publicKey: {
          challenge: challengeBuffer,
          allowCredentials: r.allowCredentials.map(({ id }) => ({
            type: "public-key",
            id: base64urlDecode(id)
          })),
          userVerification: "preferred"
        },
      })
    })
    .then((assertion) => {
      if (assertion) {
        console.log("✅ Assertion is not null : ", assertion);
        const credential = assertion as PublicKeyCredential;
        const authResponse = credential.response as AuthenticatorAssertionResponse;

        const serializedAssertion = {
          id: assertion.id,
          rawId: arrayBufferToBase64url(credential.rawId),
          type: assertion.type,
          response: {
            authenticatorData: arrayBufferToBase64url(authResponse.authenticatorData),
            clientDataJSON: arrayBufferToBase64url(authResponse.clientDataJSON),
            signature: arrayBufferToBase64url(authResponse.signature),
            // userHandle peut être null
            userHandle: authResponse.userHandle ? arrayBufferToBase64url(authResponse.userHandle) : null
          }
        };
        console.log("✅ Serialized assertion : ", serializedAssertion);
        return Services.completePasskeyAssertion(serializedAssertion, challengeId)
      } else {
        console.log("❌ Assertion does not exist.");
        return Promise.reject(null)
      }
    })
    .then(r => {
      console.debug({r})
      if (isError(r)) {
        toast.error(r.error)
      } else {
        location.reload()
      }
    })
}

export const listPasskeys = () =>
  Services.listPassKeys()
    .then(r => {
      if (isError(r)) {
        toast.error(r.error)
        return []
      } else {
        return r
      }
    })

export const deletePasskey = (passkey: IPasskey, onDelete: () => Promise<void>) => {
  return Services.deletePasskey(passkey)
    .then(() => toast.success("deletion PassKey successful"))
    .then(onDelete)
}
export const editPasskey = (passkey: IPasskey, getName: () => Promise<string | undefined>,  onDelete: () => Promise<void>) => {
  return getName()
    .then(name => Services.updatePasskey(passkey, name))
    .then(() => toast.success("update PassKey name successful"))
    .then(onDelete)
}

export const createPasskey = (user: IUserSimple, getName: () => Promise<string | undefined>, onSuccess: () => Promise<void>) => {

  return Services.beginPasskeyRegistration()
    .then(r => {
      if (isError(r))
        return Promise.reject(r.error)
      else
        return r.challenge
    })
    .then(challengeBufferString => createPassKeyCredential(
      user.email.toLowerCase(),
      user.name.toLowerCase(),
      challengeBufferString,
      user._id
    )
      .then((credential) => ({ credential: credential as PublicKeyCredential | null, challengeBufferString })))
    .then(({ credential, challengeBufferString }) => {
      console.log("✅ Created Pass Key Credential ! ")

      if (credential) {
        console.log("✅ Credential is not null : ", credential);
        // Validate PassKey Creation
        const challenge = validatePassKeyCreation(credential);
        switch (challenge) {
          case null:
            console.log("❌ PassKey verification failed.");
            return;
          default:
            console.log(`✅ PassKey verification passed with challenge : ${challenge}`);

            const response = credential.response as AuthenticatorAttestationResponse
            return getName()
              .then(name => Services.completePasskeyRegistration({
                userId: user._id,
                username: user.email,
                displayName: user.name,
                challengeBuffer: challengeBufferString,
                challenge: challenge,
                name,
                credentialId: credential.id,
                rawId: arrayBufferToBase64url(credential.rawId),
                attestationObject: arrayBufferToBase64url(response.attestationObject),
                clientDataJSON: arrayBufferToBase64url(response.clientDataJSON),
                type: credential.type,
                publicKeyAlgorithm: response.getPublicKeyAlgorithm()
              }))
              .then(() => console.log("✅ register PassKey successful"))
              .then(() => toast.success("register PassKey successful"))
              .then(onSuccess)
        }
      } else {
        console.log("❌ Credential does not exist.");
        return Promise.reject(null)
      }
    })
};

const arrayBufferToBase64url = (buffer: ArrayBuffer): string => {
  const bytes = new Uint8Array(buffer);

  let binary = '';
  bytes.forEach(byte => binary += String.fromCharCode(byte));

  return btoa(binary)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}

const base64urlDecode = (str: string): Uint8Array => {
  // Ajouter le padding si nécessaire
  const padding = '='.repeat((4 - (str.length % 4)) % 4);
  const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;

  // Décoder en base64 puis convertir en Uint8Array
  const binary = atob(base64);
  return new Uint8Array(binary.split('').map(char => char.charCodeAt(0)));
}