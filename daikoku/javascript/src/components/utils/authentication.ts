import { nanoid } from "nanoid";
import { toast } from "sonner";
import { decode, diagnose, encode } from 'cbor2';

import { isError, IUserSimple } from "../../types";
import * as Services from '../../services';
import { IPasskey } from "../backoffice";

const getKnownAAGUIDs = (): {[key: string]: {name: string} } => {
  return {
    "ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4": {
      "name": "Google Password Manager",
    },
    "adce0002-35bc-c60a-648b-0b25f1f05503": {
      "name": "Chrome on Mac",
    },
    "08987058-cadc-4b81-b6e1-30de50dcbe96": {
      "name": "Windows Hello",
    },
    "9ddd1817-af5a-4672-a2b9-3e3dd95000a9": {
      "name": "Windows Hello",
    },
    "6028b017-b1d4-4c02-b4b3-afcdafc96bb2": {
      "name": "Windows Hello",
    },
    "dd4ec289-e01d-41c9-bb89-70fa845d4bf2": {
      "name": "iCloud Keychain (Managed)",
    },
    "531126d6-e717-415c-9320-3d9aa6981239": {
      "name": "Dashlane",
    },
    "bada5566-a7aa-401f-bd96-45619a55120d": {
      "name": "1Password",
    },
    "b84e4048-15dc-4dd0-8640-f4f60813c8af": {
      "name": "NordPass",
    },
    "0ea242b4-43c4-4a1b-8b17-dd6d0b6baec6": {
      "name": "Keeper",
    },
    "891494da-2c90-4d31-a9cd-4eab0aed1309": {
      "name": "Sésame",
    },
    "f3809540-7f14-49c1-a8b3-8f813b225541": {
      "name": "Enpass",
    },
    "b5397666-4885-aa6b-cebf-e52262a439a2": {
      "name": "Chromium Browser"
    },
    "771b48fd-d3d4-4f74-9232-fc157ab0507a": {
      "name": "Edge on Mac",
    },
    "39a5647e-1853-446c-a1f6-a79bae9f5bc7": {
      "name": "IDmelon",
    },
    "d548826e-79b4-db40-a3d8-11116f7e8349": {
      "name": "Bitwarden",
    },
    "fbfc3007-154e-4ecc-8c0b-6e020557d7bd": {
      "name": "iCloud Keychain",
    },
    "53414d53-554e-4700-0000-000000000000": {
      "name": "Samsung Pass",
    },
    "66a0ccb3-bd6a-191f-ee06-e375c50b9846": {
      "name": "Thales Bio iOS SDK",
    },
    "8836336a-f590-0921-301d-46427531eee6": {
      "name": "Thales Bio Android SDK",
    },
    "cd69adb5-3c7a-deb9-3177-6800ea6cb72a": {
      "name": "Thales PIN Android SDK",
    },
    "17290f1e-c212-34d0-1423-365d729f09d9": {
      "name": "Thales PIN iOS SDK",
    },
    "50726f74-6f6e-5061-7373-50726f746f6e": {
      "name": "Proton Pass",
    },
    "fdb141b2-5d84-443e-8a35-4698c205a502": {
      "name": "KeePassXC",
    },
    "cc45f64e-52a2-451b-831a-4edd8022a202": {
      "name": "ToothPic Passkey Provider",
    },
    "bfc748bb-3429-4faa-b9f9-7cfa9f3b76d0": {
      "name": "iPasswords",
    },
    "b35a26b2-8f6e-4697-ab1d-d44db4da28c6": {
      "name": "Zoho Vault",
    },
    "b78a0a55-6ef8-d246-a042-ba0f6d55050c": {
      "name": "LastPass",
    },
    "de503f9c-21a4-4f76-b4b7-558eb55c6f89": {
      "name": "Devolutions",
    },
    "22248c4c-7a12-46e2-9a41-44291b373a4d": {
      "name": "LogMeOnce",
    },
    "a10c6dd9-465e-4226-8198-c7c44b91c555": {
      "name": "Kaspersky Password Manager",
    },
    "d350af52-0351-4ba2-acd3-dfeeadc3f764": {
      "name": "pwSafe",
    },
    "d3452668-01fd-4c12-926c-83a4204853aa": {
      "name": "Microsoft Password Manager",
    }
  };
}

const getPasskeyProvider = (credentialResponse: AuthenticatorAttestationResponse): Promise<string | undefined> => {
  if (!credentialResponse.attestationObject) return Promise.resolve(undefined);

  try {
    const attestationObject = new Uint8Array(credentialResponse.attestationObject);
    const decoded: any = decode(attestationObject);
    const authData = new Uint8Array(decoded.authData);

    // AAGUID aux bytes 37-52
    const aaguidBytes = authData.slice(37, 53);
    const hex = Array.from(aaguidBytes).map(b => b.toString(16).padStart(2, '0')).join('');
    const aaguid = `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20, 32)}`;

    console.debug({ aaguid })

    return Promise.resolve(getKnownAAGUIDs()[aaguid].name);
  } catch (error) {
    return Promise.resolve(undefined);
  }
}

export const createPassKeyCredential = (
  username: string,
  displayName: string,
  challengeBufferString: string,
  userId: string
) => {
  /*
    The challenge is a buffer of randomly generated bytes with a minimum of 16 bytes. 
    This is generated on the server using a cryptographically secure random number generator. 
    By generating the challenge on the server we can prevent "replay attacks". 
    The authenticator will sign this along with other data.
  */

  console.debug({ challengeBufferString })
  const challengeBuffer = base64urlDecode(challengeBufferString)

  const userIdBuffer = new TextEncoder().encode(userId);

  const publicKeyCredentialCreationOptions: PublicKeyCredentialCreationOptions =
  {
    authenticatorSelection: {
      authenticatorAttachment: "cross-platform",
      userVerification: "preferred",
      residentKey: "required",
    },
    challenge: challengeBuffer,
    rp: {
      name: "daikoku",
      ...(window.location.hostname !== 'localhost' && { id: window.location.hostname })
    },
    user: {
      id: userIdBuffer,
      name: username,
      displayName: displayName,
    },
    // SUPPORT ALL PASSKEYS
    pubKeyCredParams: [
      { type: "public-key", alg: -7 },   // ES256
      { type: "public-key", alg: -257 }, // RS256
      { type: "public-key", alg: -8 },   // EdDSA
    ],
    timeout: 15000,
    attestation: "none",
  };

  console.debug(
    `✅  publicKeyCredentialCreationOptions : ${publicKeyCredentialCreationOptions}`
  );

  return navigator.credentials.create({
    publicKey: publicKeyCredentialCreationOptions,
  });
};

const validatePassKeyCreation = (credential: Credential): string | null => {
  const clientDataValidation = validateClientData(credential);
  switch (clientDataValidation.valid) {
    case true:
      return clientDataValidation.challenge;
    case false:
      return null;
  }
};

interface PassKeyClientDataValidation {
  valid: boolean;
  challenge: string | null;
}
const validateClientData = (
  credential: Credential
): PassKeyClientDataValidation => {

  // Gather the Client Data
  const decoder = new TextDecoder(); // @ts-ignore
  const clientData: { type: string, challenge: string, origin: string } = JSON.parse(decoder.decode(credential.response.clientDataJSON));
  // console.debug({ clientData, credential, clientDataJSON: credential.response.clientDataJSON })
  console.log("✅  Gathered Client Data: ", clientData);
  if (clientData.origin !== "https://daikoku.oto.tools:5173") {
    console.log("❌  Origin does not match!", clientData.origin);
    return {
      valid: false,
      challenge: null,
    };
  } else if (clientData.type !== "webauthn.create") {
    console.log("❌  Type does not match webauthn.create");
    return {
      valid: false,
      challenge: null,
    };
  }
  console.log("✅  Client Data is Valid");
  return {
    valid: true,
    challenge: clientData.challenge,
  };
};


export const loginWithPasskey = () => {
  const challengeId = nanoid(32)
  Services.beginPasskeyAssertion(challengeId)
    .then(r => {
      if (isError(r))
        return Promise.reject(r.error)
      else
        return r
    })
    .then(r => {
      const challengeBuffer = base64urlDecode(r.challenge)
      return navigator.credentials.get({
        publicKey: {
          challenge: challengeBuffer,
          allowCredentials: r.allowCredentials.map(({ id }) => ({
            type: "public-key",
            id: base64urlDecode(id)
          })),
          userVerification: "preferred"
        },
      })
    })
    .then((assertion) => {
      if (assertion) {
        console.log("✅ Assertion is not null : ", assertion);
        const credential = assertion as PublicKeyCredential;
        const authResponse = credential.response as AuthenticatorAssertionResponse;

        const serializedAssertion = {
          id: assertion.id,
          rawId: arrayBufferToBase64url(credential.rawId),
          type: assertion.type,
          response: {
            authenticatorData: arrayBufferToBase64url(authResponse.authenticatorData),
            clientDataJSON: arrayBufferToBase64url(authResponse.clientDataJSON),
            signature: arrayBufferToBase64url(authResponse.signature),
            // userHandle peut être null
            userHandle: authResponse.userHandle ? arrayBufferToBase64url(authResponse.userHandle) : null
          }
        };
        console.log("✅ Serialized assertion : ", serializedAssertion);
        return Services.completePasskeyAssertion(serializedAssertion, challengeId)
      } else {
        console.log("❌ Assertion does not exist.");
        return Promise.reject(null)
      }
    })
    .then(r => {
      console.debug({ r })
      if (isError(r)) {
        toast.error(r.error)
      } else {
        location.reload()
      }
    })
}

export const listPasskeys = () =>
  Services.listPassKeys()
    .then(r => {
      if (isError(r)) {
        toast.error(r.error)
        return []
      } else {
        return r
      }
    })

export const deletePasskey = (passkey: IPasskey, onDelete: () => Promise<void>) => {
  return Services.deletePasskey(passkey)
    .then(() => toast.success("deletion PassKey successful"))
    .then(onDelete)
}
export const editPasskey = (passkey: IPasskey, getName: (name?: string) => Promise<string | undefined>, onDelete: () => Promise<void>) => {
  return getName(passkey.name)
    .then(name => Services.updatePasskey(passkey, name))
    .then(() => toast.success("update PassKey name successful"))
    .then(onDelete)
}

export const createPasskey = (user: IUserSimple, getName: (name?: string) => Promise<string | undefined>, onSuccess: () => Promise<void>) => {

  return Services.beginPasskeyRegistration()
    .then(r => {
      if (isError(r))
        return Promise.reject(r.error)
      else
        return r.challenge
    })
    .then(challengeBufferString => createPassKeyCredential(
      user.email.toLowerCase(),
      user.name.toLowerCase(),
      challengeBufferString,
      user._id
    )
      .then((credential) => ({ credential: credential as PublicKeyCredential | null, challengeBufferString })))
    .then(({ credential, challengeBufferString }) => {
      console.log("✅ Created Pass Key Credential ! ")

      if (credential) {
        console.log("✅ Credential is not null : ", credential);
        // Validate PassKey Creation
        const challenge = validatePassKeyCreation(credential);
        switch (challenge) {
          case null:
            console.log("❌ PassKey verification failed.");
            return;
          default:
            console.log(`✅ PassKey verification passed with challenge : ${challenge}`);



            const response = credential.response as AuthenticatorAttestationResponse
            return getPasskeyProvider(response)
              .then(name => getName(name))
              .then(name => Services.completePasskeyRegistration({
                userId: user._id,
                username: user.email,
                displayName: user.name,
                challengeBuffer: challengeBufferString,
                challenge: challenge,
                name,
                credentialId: credential.id,
                rawId: arrayBufferToBase64url(credential.rawId),
                attestationObject: arrayBufferToBase64url(response.attestationObject),
                clientDataJSON: arrayBufferToBase64url(response.clientDataJSON),
                type: credential.type,
                publicKeyAlgorithm: response.getPublicKeyAlgorithm()
              }))
              .then(() => console.log("✅ register PassKey successful"))
              .then(() => toast.success("register PassKey successful"))
              .then(onSuccess)
        }
      } else {
        console.log("❌ Credential does not exist.");
        return Promise.reject(null)
      }
    })
};

const arrayBufferToBase64url = (buffer: ArrayBuffer): string => {
  const bytes = new Uint8Array(buffer);

  let binary = '';
  bytes.forEach(byte => binary += String.fromCharCode(byte));

  return btoa(binary)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}

const base64urlDecode = (str: string): Uint8Array => {
  // Ajouter le padding si nécessaire
  const padding = '='.repeat((4 - (str.length % 4)) % 4);
  const base64 = str.replace(/-/g, '+').replace(/_/g, '/') + padding;

  // Décoder en base64 puis convertir en Uint8Array
  const binary = atob(base64);
  return new Uint8Array(binary.split('').map(char => char.charCodeAt(0)));
}

export const loginWithConditionalPasskey = () => {
  const challengeId = nanoid(32);

  return Services.beginPasskeyAssertion(challengeId)
    .then(r => {
      if (isError(r)) return Promise.reject(r.error);
      return r;
    })
    .then(r => {
      const challengeBuffer = base64urlDecode(r.challenge);
      return navigator.credentials.get({
        publicKey: {
          challenge: challengeBuffer,
          allowCredentials: r.allowCredentials.map(({ id }) => ({
            type: 'public-key',
            id: base64urlDecode(id),
          })),
          userVerification: 'preferred',
        },
        mediation: 'conditional',
      });
    })
    .then(assertion => {
      if (!assertion) {
        console.log('❌ Conditional passkey assertion is null.');
        return Promise.reject('No assertion');
      }

      console.log('✅ Conditional assertion: ', assertion);

      const credential = assertion as PublicKeyCredential;
      const authResponse = credential.response as AuthenticatorAssertionResponse;

      const serializedAssertion = {
        id: credential.id,
        rawId: arrayBufferToBase64url(credential.rawId),
        type: credential.type,
        response: {
          authenticatorData: arrayBufferToBase64url(authResponse.authenticatorData),
          clientDataJSON: arrayBufferToBase64url(authResponse.clientDataJSON),
          signature: arrayBufferToBase64url(authResponse.signature),
          userHandle: authResponse.userHandle
            ? arrayBufferToBase64url(authResponse.userHandle)
            : null,
        },
      };

      return Services.completePasskeyAssertion(serializedAssertion, challengeId).then(() => location.reload());
    });
};